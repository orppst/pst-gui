/**
 * Generated by @openapi-codegen
 *
 * @version 0.1
 */
/**
 * A block of resources that have been allocated
 */
export type AllocatedBlock = {
  /**
   * A resource that will be consumed by allocating an observation from a proposal
   */
  resource?: Resource;
  /**
   * a collection of configs that can be chosen to observe with.
   */
  mode?: ObservingMode;
  /**
   * The final grade given by the TAC
   */
  grade?: AllocationGrade;
};

/**
 * an instance of a proposal that is allocated observing time
 */
export type AllocatedProposal = {
  /**
   * what is allocated to the proposal
   */
  allocation?: AllocatedBlock[];
  /**
   * an instance of a proposal that has been submitted
   */
  submitted?: SubmittedProposal;
};

/**
 * The final grade given by the TAC
 */
export type AllocationGrade = {
  /**
   * the name of the grade
   */
  name?: string;
  /**
   * what this grade means
   */
  description?: string;
  xmlId?: string;
};

/**
 * The AstroCoordSystem object holds a collection of component coordinate system descriptions across all represented physical domains.
 */
export type AstroCoordSystem = {
  xmlId?: string;
  /**
   * Coordinate system description for each physical domain (Space, Time, etc).
   */
  coordSys?: PhysicalCoordSys[];
};

/**
 * The list of resources that are available
 */
export type AvailableResources = {
  resources?: Resource[];
};

/**
 * The abstract parent class for all coordinate axis types. We provide concrete classes for the most common types of data, Continuous, Binned, and Discrete, but allow extension for other types as needed.
 */
export type Axis = {
  /**
   * Freeform string, provides the name or label for the axis.
   */
  name?: string;
};

/**
 * a processing backend /pipeline- e.g. correlator
 */
export type Backend = {
  /**
   * the backend name
   */
  name?: string;
  /**
   * is capable of being run at same time as other backends
   */
  parallel?: boolean;
  xmlId?: string;
};

/**
 * Axis description for binned data, where values along the axis correspond to a bin number.
 */
export type BinnedAxis = {
  /**
   * Freeform string, provides the name or label for the axis.
   */
  name?: string;
  /**
   * The length, or number of bins, along the axis.
   *
   * @format int32
   */
  length?: number;
};

/**
 * Coordinate value type specifically intended for binned data (e.g.: pixel indexes).
 */
export type BinnedCoordinate = {
  /**
   * Abstract head of the coordinate system object tree.
   */
  coordSys?: CoordSys;
  /**
   * The binned coordinate value, expressed as an integer. e.g.: bin number, pixel index.
   *
   * @format int32
   */
  cval?: number;
};

/**
 * An observation that is intended for calibration
 */
export type CalibrationObservation = {
  "@type"?: string;
  /**
   * any constraints on the observation
   */
  constraints?: ObservingConstraint[];
  /**
   * A target source
   */
  target?: Target;
  /**
   * Definition of an observing field pointing
   */
  field?: Field;
  /**
   * collects together the technical goals of the proposal
   */
  technicalGoal?: TechnicalGoal;
  intent?: CalibrationTargetIntendedUse;
};

export type CalibrationTargetIntendedUse =
  | "AMPLITUDE"
  | "ATMOSPHERIC"
  | "BANDPASS"
  | "PHASE"
  | "POINTING"
  | "FOCUS"
  | "POLARIZATION"
  | "DELAY";

/**
 * Spatial domain, three-dimensional cartesian coordinate space. The particulars of the axis descriptions depend on the physical constraints of the instance. In Appendix B, we provide the description of a Standard Cartesian Coordinate Space instance which applies to many Astronomical cases, and may be referenced in serializations.
 */
export type CartesianCoordSpace = {
  "@type"?: string; // coords:CartesianCoordSpace
  axis?: Axis[];
};

/**
 * A spatial coordinate in a Cartesian coordinate space. Any associated CoordSpace MUST be a CartesianCoordSpace. If no CoordSpace is provided, a Standard Cartesian CoordSpace is assumed. Values for unused/undefined dimensions need not be provided.
 */
export type CartesianPoint = {
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  x?: Quantity;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  y?: Quantity;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  z?: Quantity;
};

/**
 * The basic target setup for a celestial Target.
 */
export type CelestialTarget = {
  xmlId?: string;
  "@type"?: string; // proposal:CelestialTarget
  /**
   * A common name for the source
   */
  sourceName?: string;
  /**
   * A Point on the Unit Sphere
   */
  sourceCoordinates?: EquatorialPoint;
  /**
   * We define epoch as a primitive data type with the expected form '$type$year' where type = 'J' or 'B' for Julian or Besselian respectively, and year is expressed as a decimal year. e.g.: 'B1950', 'J2000.0'
   */
  positionEpoch?: Epoch;
  /**
   * A real value with a unit.
   */
  pmRA?: RealQuantity;
  /**
   * A real value with a unit.
   */
  pmDec?: RealQuantity;
  /**
   * A real value with a unit.
   */
  parallax?: RealQuantity;
  /**
   * A real value with a unit.
   */
  sourceVelocity?: RealQuantity;
};

/**
 * a member of the TAC
 */
export type CommitteeMember = {
  /**
   * A role within the timeAllocation committee
   */
  role?: TacRole;
  /**
   * assigned to review the proposal
   */
  member?: Reviewer;
};

export type Composites = {
  /**
   * @uniqueItems true
   */
  realm?: string[];
  client?: {
    [key: string]: string[];
  };
  /**
   * @deprecated true
   */
  application?: {
    [key: string]: string[];
  };
};

/**
 * Axis description for continuous data. This object describes the domain for a particular axis of the domain space. It allows for the specification of the legal domain range (min,max), and a flag indicating if the axis is cyclic.
 */
export type ContinuousAxis = {
  /**
   * Freeform string, provides the name or label for the axis.
   */
  name?: string;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  domainMin?: Quantity;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  domainMax?: Quantity;
  /**
   * Flag indicating if the axis is cyclic in nature. If not provided, it is assumed to be FALSE.
   */
  cyclic?: boolean;
};

/**
 * This is the abstract, empty, base class for all coordinate frames. Coordinate frames provide metadata associated with the coordinate domain space. Typically, this will be related to the origin and orientation of the axes, but might include any metadata which pertains to the definition of the domain.
 */
export type CoordFrame = Record<string, any>;

/**
 * This object defines a domain space. i.e.: it describes the set of possible coordinate values.
 */
export type CoordSpace = {
  /**
   * Describes an axis of the coordinate space.
   */
  axis?: Axis[];
};

/**
 * Abstract head of the coordinate system object tree.
 */
export type CoordSys = Record<string, any>;

/**
 * Abstract base class for the Coordinate data types which represent an absolute location within a coordinate space. Coordinates MUST refer to a coordinate system, providing additional metadata relevant to interpreting the coordinate value, and its representation.
 */
export type Coordinate = {
  /**
   * Abstract head of the coordinate system object tree.
   */
  coordSys?: CoordSys;
};

export type CredentialRepresentation = {
  id?: string;
  type?: string;
  userLabel?: string;
  /**
   * @format int64
   */
  createdDate?: number;
  secretData?: string;
  credentialData?: string;
  /**
   * @format int32
   */
  priority?: number;
  value?: string;
  temporary?: boolean;
  /**
   * @deprecated true
   */
  device?: string;
  /**
   * @deprecated true
   */
  hashedSaltedValue?: string;
  /**
   * @deprecated true
   */
  salt?: string;
  /**
   * @format int32
   * @deprecated true
   */
  hashIterations?: number;
  /**
   * @format int32
   * @deprecated true
   */
  counter?: number;
  /**
   * @deprecated true
   */
  algorithm?: string;
  /**
   * @format int32
   * @deprecated true
   */
  digits?: number;
  /**
   * @format int32
   * @deprecated true
   */
  period?: number;
  /**
   * @deprecated true
   */
  config?: MultivaluedHashMapStringString;
};

/**
 * A custom reference location in phase space (position and velocity). Position and velocity are given as coordinates with an associated SpaceFrame. An epoch MAY be provided to further refine the location.
 */
export type CustomRefLocation = {
  /**
   * We define epoch as a primitive data type with the expected form '{type}{year}' where type = 'J' or 'B' for Julian or Besselian respectively, and year is expressed as a decimal year. e.g.: 'B1950', 'J2000.0'
   */
  epoch?: Epoch;
  /**
   * Multi-dimensional spatial coordinate. The Point MUST refer to a spatial coordinate system (SpaceSys) which associates the point with corresponding coordinate domain space and frame metadata.
   */
  position?: Point1;
  /**
   * Multi-dimensional spatial coordinate. The Point MUST refer to a spatial coordinate system (SpaceSys) which associates the point with corresponding coordinate domain space and frame metadata.
   */
  velocity?: Point1;
};

/**
 * @format date
 * @example "2022-03-10T00:00:00.000Z"
 */
export type Date = string;

/**
 * Axis type specifically intended for enumerated coordinates. Since the content and nature of this axis type is heavily dependent on the use case, we define no additional metadata here. Extensions of this type may include additional metadata relevant to the particular use cases. For example, an extension could include the allowed set of values.
 */
export type DiscreteSetAxis = {
  /**
   * Freeform string, provides the name or label for the axis.
   */
  name?: string;
};

/**
 * Specialization of a Field for an elliptical map.
 */
export type Ellipse = {
  xmlId?: string;
  name?: string;
  /**
   * A real value with a unit.
   */
  semiMajor?: RealQuantity;
  /**
   * A real value with a unit.
   */
  semiMinor?: RealQuantity;
  /**
   * A real value with a unit.
   */
  pAMajor?: RealQuantity;
};

/**
 * We define epoch as a primitive data type with the expected form '{type}{year}' where type = 'J' or 'B' for Julian or Besselian respectively, and year is expressed as a decimal year. e.g.: 'B1950', 'J2000.0'
 */
export type Epoch = {
  value?: string;
};

/**
 * A Point on the Unit Sphere
 */
export type EquatorialPoint = {
  "@type": string; // coords:EquatorialPoint
  coordSys: CoordSys;
  /**
   * A real value with a unit.
   */
  lon?: RealQuantity;
  /**
   * A real value with a unit.
   */
  lat?: RealQuantity;
};

/**
 * Brief description of a spectral line.
 */
export type ExpectedSpectralLine = {
  /**
   * A real value with a unit.
   */
  restFrequency?: RealQuantity;
  transition?: string;
  /**
   * a string identifier that can be used as a key for lookup of an entity that is *outside this datamodel*
   */
  splatalogId?: StringIdentifier;
  description?: string;
};

/**
 * Extension of TimeInstant for time expressed as a structured datetime string. The string representation of a datetime value should follow the FITS convention for representing dates (Hanish and Farris et al, 2001). The FITS standard is effectively ISO8601 format without the 'Z' tag to indicate UTC: YYYY-MM-DD['T'hh:mm:ss[.SSS]]. The TimeScale is provided in the associated TimeFrame.
 */
export type FITSTime = {
  /**
   * The FITSTime coordinate value.
   */
  date?: string;
};

export type FederatedIdentityRepresentation = {
  identityProvider?: string;
  userId?: string;
  userName?: string;
};

/**
 * Definition of an observing field pointing
 */
export type Field = {
  "@type"?: string;
  name?: string;
  xmlId?: string;
  _id?: number;
};

export type FileUpload = Record<string, any>;

/**
 * Generic, one-dimensional coordinate space suitable for use with most non-spatial properties. In Appendix B, we provide the description of a Standard 1D Coordinate Space instance which may be referenced in serializations.
 */
export type GenericCoordSpace = {
  /**
   * Describes an axis of the coordinate space.
   */
  axis?: Axis[];
};

/**
 * The generic coordinate frame is for cases where a domain-specific frame (e.g.: Space, Time), is not required, but the relevant reference metadata is still needed (e.g.: for Redshift or Spectral data)
 */
export type GenericFrame = {
  /**
   * RefLocation defines the origin of the spatial coordinate space. This location is represented either by a standard reference position (for which the absolute location in phase space is known by definition), or a specified point in another Spatial frame. This object is used as the origin of the SpaceFrame here, but also to specify the Spatial Reference Position (refPosition) associated with other domain Frames. For example, in the Time domain, the Spatial Reference Position indicates that the 'time' values are the time that the 'event' occured at that location, which might be different from the detector location.
   */
  refPosition?: RefLocation;
  /**
   * A planetary ephemeris MAY be provided, and SHOULD be provided whenever appropriate, to indicate which solar system ephemeris was used. If needed, but not provided, it is assumed to be 'DE405'
   */
  planetaryEphem?: string;
};

/**
 * GenericPoint supports the representation of spatial coordinates in a custom coordinate space, or any space which is not covered by the other specializations. The coordinate values map, in order, to the axes described by the associated CoordSpace. If no CoordSpace is provided, the behavior is undefined. Values for unused/undefined dimensions need not be provided.
 */
export type GenericPoint = {
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  axis1?: Quantity;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  axis2?: Quantity;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  axis3?: Quantity;
};

/**
 * Specialized coordinate system for generic, one-dimensional domains not covered by other, more concrete objects. If a CoordSpace is not provided, it is assumed to be represented by a Standard 1-Dimensional Coordinate Space as described in Appendix B.
 */
export type GenericSys = {
  xmlId?: string;
  /**
   * Abstract head of coordinate spaces related to physical properties.
   */
  coordSpace?: PhysicalCoordSpace;
};

/**
 * The handedness of a coordinate space. For most cases, this will be a fixed value in the specification of the coordinate space. We provide this element to allow this flexibility when needed. In this document, it is used in the Pixel domain.
 */
export type Handedness = "LEFT" | "RIGHT";

/**
 * An instrument that can be attached to a telescope - e.g. CCD, Radio Receiver
 */
export type Instrument = {
  /**
   * the instrument name - human readable
   */
  name?: string;
  /**
   * short human readable description
   */
  description?: string;
  /**
   * a WikiData identifier
   */
  wikiId?: WikiDataId;
  /**
   * a URL that points to a more detailed description of the instrument
   */
  reference?: string;
  kind?: InstrumentKind;
  /**
   * Science oriented definition of a spectral window.
   */
  frequencyCoverage?: SpectralWindowSetup;
  xmlId?: string;
};

export type InstrumentKind = "CONTINUUM" | "SPECTROSCOPIC";

/**
 * an integer identifier that can be used as a key for lookup of an entity that is *outside this datamodel*
 */
export type IntIdentifier = {
  /**
   * @format int32
   */
  value?: number;
};

/**
 * An integer number with a unit. Examples of such units that can be used for attributes are bit/byte/kiloByte etc.
 */
export type IntegerQuantity = {
  /**
   * Must conform to definition of unit in VOUnit spec.
   */
  unit?: Unit;
  /**
   * The integer value of this IntegerQuantity.
   *
   * @format int32
   */
  value?: number;
};

export type Investigator = {
  type?: InvestigatorKind;
  /**
   * is the investigator making proposal for their PhD
   */
  forPhD?: boolean;
  /**
   * person connected with the proposal
   */
  person?: Person;
};

export type InvestigatorKind = "PI" | "COI";

/**
 * an identifier that can be used as a key to look up in an IVOA registry - see https://www.ivoa.net/documents/IVOAIdentifiers/
 */
export type Ivorn = {
  value?: string;
};

/**
 * Extension of TimeInstant for time expressed in Julian days. Note that JD does not properly specify a time stamp unless it is related to a time scale and reference position. Precision can easily become an issue with JD, as the numbers tend to be large.
 */
export type Jd = {
  /**
   * The JD coordinate value. JD dates are dimensionless, with implied units in days.
   *
   * @format double
   */
  date?: number;
};

/**
 * The justification for the proposal. Note that the justification is for reading by humans and is not parsed to extract things like source lists - that sort of information must be entered in the correct place in the model.
 */
export type Justification = {
  /**
   * the full text of the justification
   */
  text?: string;
  /**
   * acceptable text formats for document submission
   */
  format?: TextFormats;
};

/**
 * A spatial coordinate in a Spherical coordinate space defining a Celestial position in Latitude and Longitude. Any associated CoordSpace MUST conform to this description. If no CoordSpace is provided, a Standard Spherical CoordSpace is assumed. Values for unused/undefined dimensions need not be provided.
 */
export type LonLatPoint = {
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  lon?: Quantity;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  lat?: Quantity;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  dist?: Quantity;
};

/**
 * Extension of TimeInstant for time expressed in Modified Julian Days. T(MJD) = T(JD) - 2400000.5.
 */
export type Mjd = {
  /**
   * The MJD coordinate value. MJD dates are dimensionless, with implied units in days.
   *
   * @format double
   */
  date?: number;
};

export type MultivaluedHashMapStringString = {
  [key: string]: string[];
};

export type ObjectIdentifier = {
  /**
   * @format int64
   */
  dbid?: number;
  code?: string;
  name?: string;
};

export type ObsType = "TargetObservation" | "CalibrationObservation";

export type Observation = {
  "@type"?: string; //ObsType (see above)
  /**
   * any constraints on the observation
   */
  constraints?: ObservingConstraint[];
  /**
   * A target source
   */
  target?: Target;
  /**
   * Definition of an observing field pointing
   */
  field?: Field;
  /**
   * collects together the technical goals of the proposal
   */
  technicalGoal?: TechnicalGoal;
};

/**
 * An organisation that can perform astronomical observations
 */
export type Observatory = {
  xmlId?: string;
  /**
   * The name of the organization
   */
  name?: string;
  address?: string;
  /**
   * an identifier that can be used as a key to look up in an IVOA registry - see https://www.ivoa.net/documents/IVOAIdentifiers/
   */
  ivoid?: Ivorn;
  /**
   * a WikiData identifier
   */
  wikiId?: WikiDataId;
  /**
   * the telescopes that the observatory controls
   */
  telescopes?: Telescope[];
  /**
   * the instruments that are available for the telescopes
   */
  instruments?: Instrument[];
  /**
   * the backends that exist
   */
  backends?: Backend[];
  /**
   * any arrays of telescopes that typically operate together
   */
  arrays?: TelescopeArray[];
};

/**
 * A particular observation combination that is possible
 */
export type ObservingConfiguration = {
  telescope?: Telescope;
  /**
   * An instrument that can be attached to a telescope - e.g. CCD, Radio Receiver
   */
  instrument?: Instrument;
  /**
   * a processing backend /pipeline- e.g. correlator
   */
  backend?: Backend;
};

/**
 * a form of constraint on the observation
 */
export type ObservingConstraint = Record<string, any>;

/**
 * a collection of configs that can be chosen to observe with.
 */
export type ObservingMode = {
  name?: string;
  description?: string;
  configurations?: ObservingConfiguration[];
  xmlId?: string;
};

/**
 * a complete proposal
 */
export type ObservingProposal = {
  "_id"?: number;
  /**
   * the proposal title
   */
  title?: string;
  /**
   * a short summary/abstract of the proposal
   */
  summary?: string;
  kind?: ProposalKind;
  /**
   * whether the proposal is submitted
   */
  submitted?: boolean;
  /**
   * The justification for the proposal. Note that the justification is for reading by humans and is not parsed to extract things like source lists - that sort of information must be entered in the correct place in the model.
   */
  scientificJustification?: Justification;
  /**
   * The justification for the proposal. Note that the justification is for reading by humans and is not parsed to extract things like source lists - that sort of information must be entered in the correct place in the model.
   */
  technicalJustification?: Justification;
  /**
   * the person(s) making the proposal
   */
  investigators?: Investigator[];
  relatedProposals?: RelatedProposal[];
  /**
   * any additional documents
   */
  supportingDocuments?: SupportingDocument[];
  /**
   * the targets of the proposal
   */
  targets?: Target[];
  /**
   * the fields observed in the proposal
   */
  fields?: Field[];
  /**
   * the technical goals of the proposal
   */
  technicalGoals?: TechnicalGoal[];
  /**
   * the proposed observations
   */
  observations?: Observation[];
  xmlId?: string;
};

export type OfferedCycles = {
  cycles?: ProposalCycle[];
};

/**
 * An institution that is a collection of people
 */
export type Organization = {
  /**
   * The name of the organization
   */
  name?: string;
  address?: string;
  /**
   * an identifier that can be used as a key to look up in an IVOA registry - see https://www.ivoa.net/documents/IVOAIdentifiers/
   */
  ivoid?: Ivorn;
  /**
   * a WikiData identifier
   */
  wikiId?: WikiDataId;
  xmlId?: string;
};

/**
 * The parameters required for observation to be useful for the science goal
 */
export type PerformanceParameters = {
  /**
   * A real value with a unit.
   */
  desiredAngularResolution?: RealQuantity;
  /**
   * A real value with a unit.
   */
  desiredLargestScale?: RealQuantity;
  /**
   * A real value with a unit.
   */
  desiredSensitivity?: RealQuantity;
  /**
   * A real value with a unit.
   */
  desiredDynamicRange?: RealQuantity;
  /**
   * A real value with a unit.
   */
  representativeSpectralPoint?: RealQuantity;
};

/**
 * person connected with the proposal
 */
export type Person = {
  /**
   * The given names for the person
   */
  fullName?: string;
  /**
   * an email that can be used to communicate with the person
   */
  eMail?: string;
  /**
   * a string identifier that can be used as a key for lookup of an entity that is *outside this datamodel*
   */
  orcidId?: StringIdentifier;
  /**
   * An institution that is a collection of people
   */
  homeInstitute?: Organization;
  xmlId?: string;
};

/**
 * Abstract head of coordinate spaces related to physical properties.
 */
export type PhysicalCoordSpace = {
  /**
   * Describes an axis of the coordinate space.
   */
  axis?: Axis[];
};

/**
 * Coordinate system description for any physical domain, such as Time, Space, Redshift, Temperature, Flux, etc.
 */
export type PhysicalCoordSys = {
  xmlId?: string;
  /**
   * Abstract head of coordinate spaces related to physical properties.
   */
  coordSpace?: PhysicalCoordSpace;
  /**
   * This is the abstract, empty, base class for all coordinate frames. Coordinate frames provide metadata associated with the coordinate domain space. Typically, this will be related to the origin and orientation of the axes, but might include any metadata which pertains to the definition of the domain.
   */
  frame?: CoordFrame;
};

/**
 * The most common type of coordinate value. This type is appropriate for any data whose values can be described by an ivoa:Quantity (numeric, with unit).
 */
export type PhysicalCoordinate = {
  /**
   * Abstract head of the coordinate system object tree.
   */
  coordSys?: CoordSys;
  /**
   * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
   */
  cval?: Quantity;
};

/**
 * The PixelCoordSystem provides a complete description of the pixel coordinate space. It SHALL contain one PixelSpace instance describing each pixel axis.
 */
export type PixelCoordSystem = {
  xmlId?: string;
  /**
   * A PixelSpace SHALL include one or more BinnedAxis objects describing the pixel coordinate space. A handedness value MAY be provided to specify the relative orientation of the axes.
   */
  pixelSpace?: PixelSpace;
};

/**
 * Specialized BinnedCoordinate for the pixel domain for a 1-dimensional pixel index. PixelIndex MUST refer to a PixelCoordSystem.
 */
export type PixelIndex = {
  /**
   * Abstract head of the coordinate system object tree.
   */
  coordSys?: CoordSys;
  /**
   * The binned coordinate value, expressed as an integer. e.g.: bin number, pixel index.
   *
   * @format int32
   */
  cval?: number;
};

/**
 * A PixelSpace SHALL include one or more BinnedAxis objects describing the pixel coordinate space. A handedness value MAY be provided to specify the relative orientation of the axes.
 */
export type PixelSpace = {
  /**
   * The handedness of a coordinate space. For most cases, this will be a fixed value in the specification of the coordinate space. We provide this element to allow this flexibility when needed. In this document, it is used in the Pixel domain.
   */
  handedness?: Handedness;
  axis?: Axis[];
};

/**
 * Single point on the sky
 */
export type Point = {
  xmlId?: string;
  name?: string;
  /**
   * Multi-dimensional spatial coordinate. The Point MUST refer to a spatial coordinate system (SpaceSys) which associates the point with corresponding coordinate domain space and frame metadata.
   */
  centre?: Point1;
};

/**
 * Multi-dimensional spatial coordinate. The Point MUST refer to a spatial coordinate system (SpaceSys) which associates the point with corresponding coordinate domain space and frame metadata.
 */
export type Point1 = Record<string, any>;

/**
 * A constraint that limits the telescope pointing
 */
export type PointingConstaint = Record<string, any>;

/**
 * Abstract head of the polarization coordinate types. Current use cases only require support for discrete polarization states, however, we include this head class to facilitate extension for other types (eg: polarization fraction and angle).
 */
export type PolCoordinate = {
  /**
   * Abstract head of the coordinate system object tree.
   */
  coordSys?: CoordSys;
};

/**
 * Coordinate type for discrete polarization states.
 */
export type PolState = {
  /**
   * Abstract head of the coordinate system object tree.
   */
  coordSys?: CoordSys;
  /**
   * Polarization states: Stokes, Circular, Linear and Vector states
   */
  cval?: PolStateEnum;
};

/**
 * Polarization states: Stokes, Circular, Linear and Vector states
 */
export type PolStateEnum =
  | "I"
  | "Q"
  | "U"
  | "V"
  | "RR"
  | "LL"
  | "RL"
  | "LR"
  | "XX"
  | "YY"
  | "XY"
  | "YX"
  | "PF"
  | "PP"
  | "PA";

/**
 * Polygonal map
 */
export type Polygon = {
  xmlId?: string;
  name?: string;
  /**
   * an array of points....
   */
  points?: EquatorialPoint[];
};

/**
 * Defines collection of resources and proposals for a particular observing season
 */
export type ProposalCycle = {
  /**
   * a human readable description of the cycle
   */
  title?: string;
  /**
   * the date by which observing proposals must be submitted to be considered for this cycle
   *
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  submissionDeadline?: Date;
  /**
   * the start date of the observing cycle
   *
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  observationSessionStart?: Date;
  /**
   * the end date of the observing cycle
   *
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  observationSessionEnd?: Date;
  /**
   * the possible observing modes offered in the cycle
   */
  observingModes?: ObservingMode[];
  /**
   * The list of resources that are available
   */
  availableResources?: AvailableResources;
  /**
   * The possible grades that can be allocated for this cycle
   */
  possibleGrades?: AllocationGrade[];
  /**
   * time allocation committee
   */
  tac?: Tac;
  /**
   * the proposals that have been submitted in this cycle
   */
  submittedProposals?: SubmittedProposal[];
  /**
   * the proposals that have been reviewed in this cycle
   */
  reviewedProposals?: ReviewedProposal[];
  /**
   * the proposals that have been successful and allocated time
   */
  allocatedProposals?: AllocatedProposal[];
  /**
   * An organisation that can perform astronomical observations
   */
  observatory?: Observatory;
};

export type ProposalCycleDates = {
  title?: string;
  submissionDeadline?: Date;
  observationSessionStart?: Date;
  observationSessionEnd?: Date;
};

export type ProposalKind = "STANDARD" | "TOO" | "SURVEY";

/**
 * A review of a proposal
 */
export type ProposalReview = {
  /**
   * Description
   */
  comment?: string;
  /**
   * the review score
   *
   * @format double
   */
  score?: number;
  /**
   * is the proposal technically feasible
   */
  technicalFeasibility?: boolean;
  /**
   * the date that the review is submitted
   *
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  reviewDate?: Date;
  /**
   * assigned to review the proposal
   */
  reviewer?: Reviewer;
};

export type ProposalSynopsis = {
  /**
   * @format int64
   */
  code?: number;
  title?: string;
  summary?: string;
  kind?: ProposalKind;
  submitted?: boolean;
};

export type ProposalValidation = {
  /**
   * @format int64
   */
  id?: number;
  title?: string;
  isValid?: boolean;
  info?: string;
  warnings?: string;
  errors?: string;
};

/**
 * Meant to represent the value of a numerical physical quantity. Can be mapped in VOTables to FIELDrefs and PARAM(ref)s, in which case the @unit attribute of those VOTable elements is assumed to be mapped to the attribute on the Quantity. Ths is only allowed for these predefined ivoa types.
 */
export type Quantity = {
  /**
   * Must conform to definition of unit in VOUnit spec.
   */
  unit?: Unit;
};

/**
 * A spatial coordinate in a Cartesian coordinate space. Any associated CoordSpace MUST be a CartesianCoordSpace. If no CoordSpace is provided, a Standard Cartesian CoordSpace is assumed. Real values are used in the cartesian points.
 */
export type RealCartesianPoint = {
  /**
   * A real value with a unit.
   */
  x?: RealQuantity;
  /**
   * A real value with a unit.
   */
  y?: RealQuantity;
  /**
   * A real value with a unit.
   */
  z?: RealQuantity;
};

/**
 * A real value with a unit.
 */
export type RealQuantity = {
  "@type"?: string; // ivoa:RealQuantity
  /**
   * Must conform to definition of unit in VOUnit spec.
   */
  unit?: Unit;
  /**
   * The real value of this quantity
   *
   * @format double
   */
  value?: number;
};

/**
 * RefLocation defines the origin of the spatial coordinate space. This location is represented either by a standard reference position (for which the absolute location in phase space is known by definition), or a specified point in another Spatial frame. This object is used as the origin of the SpaceFrame here, but also to specify the Spatial Reference Position (refPosition) associated with other domain Frames. For example, in the Time domain, the Spatial Reference Position indicates that the 'time' values are the time that the 'event' occured at that location, which might be different from the detector location.
 */
export type RefLocation = Record<string, any>;

/**
 * a related proposal
 */
export type RelatedProposal = {
  /**
   * a complete proposal
   */
  proposal?: ObservingProposal;
};

/**
 * A resource that will be consumed by allocating an observation from a proposal
 */
export type Resource = {
  /**
   * The amount of the resource
   *
   * @format double
   */
  amount?: number;
  /**
   * a type of resource
   */
  type?: ResourceType;
};

/**
 * A block of resources that can be allocated
 */
export type ResourceBlock = {
  /**
   * A resource that will be consumed by allocating an observation from a proposal
   */
  resource?: Resource;
  /**
   * a collection of configs that can be chosen to observe with.
   */
  mode?: ObservingMode;
};

/**
 * a type of resource
 */
export type ResourceType = {
  /**
   * the name of the resource type
   */
  name?: string;
  unit?: string;
  xmlId?: string;
};

/**
 * an instance of a proposal that is in review
 */
export type ReviewedProposal = {
  /**
   * the proposal can go on to allocation
   */
  successful?: boolean;
  /**
   * the date when all the proposals are due
   *
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  reviewsCompleteDate?: Date;
  /**
   * the reviews
   */
  reviews?: ProposalReview[];
  /**
   * an instance of a proposal that has been submitted
   */
  submitted?: SubmittedProposal;
};

/**
 * assigned to review the proposal
 */
export type Reviewer = {
  /**
   * person connected with the proposal
   */
  person?: Person;
  xmlId?: string;
};

export type RoleRepresentation = {
  id?: string;
  name?: string;
  description?: string;
  /**
   * @deprecated true
   */
  scopeParamRequired?: boolean;
  composite?: boolean;
  composites?: Composites;
  clientRole?: boolean;
  containerId?: string;
  attributes?: {
    [key: string]: string[];
  };
};

/**
 * A spectral window for science use.
 */
export type ScienceSpectralWindow = {
  /**
   * Science oriented definition of a spectral window.
   */
  spectralWindowSetup?: SpectralWindowSetup;
  expectedSpectralLine?: ExpectedSpectralLine[];
};

export type SimbadTargetResult = {
  targetName?: string;
  spaceSystemCode?: string;
  epoch?: string;
  /**
   * @format double
   */
  raDegrees?: number;
  /**
   * @format double
   */
  decDegrees?: number;
};

/**
 * A constraint that requires that two observations occur simultaneously
 */
export type SimultaneityConstraint = {
  note?: string;
  isAvoidConstraint?: boolean;
};

export type SocialLinkRepresentation = {
  socialProvider?: string;
  socialUserId?: string;
  socialUsername?: string;
};

export type SolarSystemTarget = {
  xmlId?: string;
  /**
   * A common name for the source
   */
  sourceName?: string;
};

/**
 * A SpaceFrame is specified by its reference frame (orientation), and a reference position (origin). Currently only standard reference frames are allowed. An equinox MUST be provided for pre-ICRS reference frames. A planetary ephemeris MAY be provided if relevant. If needed, but not provided, it is assumed to be 'DE405'.
 */
export type SpaceFrame = {
  "@type": string; // coords:SpaceFrame
  /**
   * RefLocation defines the origin of the spatial coordinate space. This location is represented either by a standard reference position (for which the absolute location in phase space is known by definition), or a specified point in another Spatial frame. This object is used as the origin of the SpaceFrame here, but also to specify the Spatial Reference Position (refPosition) associated with other domain Frames. For example, in the Time domain, the Spatial Reference Position indicates that the 'time' values are the time that the 'event' occured at that location, which might be different from the detector location.
   */
  refPosition?: RefLocation;
  /**
   * The spatial reference frame. Values MUST be selected from the controlled vocabulary at the given URL.
   */
  spaceRefFrame?: string;
  /**
   * We define epoch as a primitive data type with the expected form '{type}{year}' where type = 'J' or 'B' for Julian or Besselian respectively, and year is expressed as a decimal year. e.g.: 'B1950', 'J2000.0'
   */
  equinox?: Epoch;
  /**
   * Ephemeris file for solar system objects SHOULD be specified whenever relevant.
   */
  planetaryEphem?: string;
};

/**
 * Specialized coordinate system for the Spatial domain. This object SHOULD include an appropriate SpaceFrame. In Appendix B, we define two standard spatial coordinate space instances (Spherical and Cartesian), which may be referenced in serializations. If a CoordSpace is not provided, it is assumed to be represented by a Standard Spherical Coordinate Space.
 */
export type SpaceSys = {
  "@type": string; // coords:SpaceSys
  xmlId?: string;
  /**
   * Abstract head of coordinate spaces related to physical properties.
   */
  coordSpace?: PhysicalCoordSpace;
};

/**
 * Science oriented definition of a spectral window.
 */
export type SpectralWindowSetup = {
  /**
   * A real value with a unit.
   */
  start?: RealQuantity;
  /**
   * A real value with a unit.
   */
  end?: RealQuantity;
  /**
   * A real value with a unit.
   */
  spectralResolution?: RealQuantity;
  /**
   * represents an observed frequency
   */
  isSkyFrequency?: boolean;
  /**
   * Polarization states: Stokes, Circular, Linear and Vector states
   */
  polarization?: PolStateEnum;
};

/**
 * Spatial domain, three-dimensional spherical coordinate space. The particulars of the axis descriptions depend on the flavor of space being instantiated. In Appendix B., we provide a Standard Spherical Coordinate Space instance which applies to many Astronomical use cases. It provides the default space for SpaceSys instances, and may be referenced in serializations.
 */
export type SphericalCoordSpace = {
  axis?: Axis[];
};

/**
 * A point in space expressed in spherical coordinates
 */
export type SphericalPoint = {
  /**
   * A real value with a unit.
   */
  r?: RealQuantity;
  /**
   * A real value with a unit.
   */
  theta?: RealQuantity;
  /**
   * A real value with a unit.
   */
  phi?: RealQuantity;
};

/**
 * An absolute a-priori known location in phase space (position and velocity). Values are selected from the StdRefPosition vocabulary. Considering that the GEOCENTER is really the only place for which we know the absolute location at all times, all other locations require the specification of a planetary ephemeris. LSR[KD] are reserved for spectral and reshift frames. TOPOCENTER (location of the observer) is special in that it assumes that the observing location is available through other means (e.g. a geographic location or an orbit ephemeris). RELOCATABLE is available for simulations. UNKNOWN should only be used if absolutely necessary.
 */
export type StdRefLocation = {
  /**
   * Standard reference location. Values MUST be selected from the controlled vocabulary at the given URL.
   */
  position?: string;
};

/**
 * a string identifier that can be used as a key for lookup of an entity that is *outside this datamodel*
 */
export type StringIdentifier = {
  value?: string;
};

export type SubjectMap = {
  /**
   * @format int64
   */
  _id?: number;
  /**
   * person connected with the proposal
   */
  person?: Person | Person;
  uid?: string;
  inKeycloakRealm?: boolean;
};

/**
 * an instance of a proposal that has been submitted
 */
export type SubmittedProposal = {
  /**
   * the date that the proposal was submitted
   *
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  submissionDate?: Date;
  /**
   * a complete proposal
   */
  proposal?: ObservingProposal;
  xmlId?: string;
};

/**
 * a document
 */
export type SupportingDocument = {
  /**
   * document title
   */
  title?: string;
  /**
   * location of document
   */
  location?: string;
};

/**
 * time allocation committee
 */
export type Tac = {
  /**
   * members of the committee
   */
  members?: CommitteeMember[];
};

/**
 * A role within the timeAllocation committee
 */
export type TacRole = "TECHNICALREVIEWER" | "SCIENCEREVIEWER" | "CHAIR";

/**
 * A target source
 */
export type Target = {
  "@type"?: string;
  /**
   * A common name for the source
   */
  sourceName?: string;
  xmlId?: string;
  _id?: number;
};

/**
 * the field points to the associated target
 */
export type TargetField = {
  xmlId?: string;
  name?: string;
};

/**
 * an observation of the scientific target
 */
export type TargetObservation = {
  "@type"?: string;
  /**
   * any constraints on the observation
   */
  constraints?: ObservingConstraint[];
  /**
   * A target source
   */
  target?: Target;
  /**
   * Definition of an observing field pointing
   */
  field?: Field;
  /**
   * collects together the technical goals of the proposal
   */
  technicalGoal?: TechnicalGoal;
};

/**
 * collects together the technical goals of the proposal
 */
export type TechnicalGoal = {
  /**
   * The parameters required for observation to be useful for the science goal
   */
  performance?: PerformanceParameters;
  spectrum?: ScienceSpectralWindow[];
  _id?: number;
  xmlId?: string;
};

export type Telescope = {
  /**
   * telescope name
   */
  name?: string;
  /**
   * a WikiData identifier
   */
  wikiId?: WikiDataId;
  /**
   * A spatial coordinate in a Cartesian coordinate space. Any associated CoordSpace MUST be a CartesianCoordSpace. If no CoordSpace is provided, a Standard Cartesian CoordSpace is assumed. Real values are used in the cartesian points.
   */
  location?: RealCartesianPoint;
  xmlId?: string;
};

/**
 * a set of telescopes that are operated together for an observation
 */
export type TelescopeArray = {
  /**
   * the array name
   */
  name?: string;
  /**
   * the telescopes that make up the array
   */
  arrayMembers?: TelescopeArrayMember[];
};

export type TelescopeArrayMember = {
  telescope?: Telescope;
};

/**
 * acceptable text formats for document submission
 */
export type TextFormats = "LATEX" | "RST" | "ASCIIDOC";

/**
 * A TimeFrame SHALL include a time scale and reference position. It MAY also include a reference direction.
 */
export type TimeFrame = {
  /**
   * RefLocation defines the origin of the spatial coordinate space. This location is represented either by a standard reference position (for which the absolute location in phase space is known by definition), or a specified point in another Spatial frame. This object is used as the origin of the SpaceFrame here, but also to specify the Spatial Reference Position (refPosition) associated with other domain Frames. For example, in the Time domain, the Spatial Reference Position indicates that the 'time' values are the time that the 'event' occured at that location, which might be different from the detector location.
   */
  refPosition?: RefLocation;
  /**
   * The time scale sets the reference frame. The value MUST be selected from the controlled vocabulary at the given URL.
   */
  timescale?: string;
  /**
   * RefLocation defines the origin of the spatial coordinate space. This location is represented either by a standard reference position (for which the absolute location in phase space is known by definition), or a specified point in another Spatial frame. This object is used as the origin of the SpaceFrame here, but also to specify the Spatial Reference Position (refPosition) associated with other domain Frames. For example, in the Time domain, the Spatial Reference Position indicates that the 'time' values are the time that the 'event' occured at that location, which might be different from the detector location.
   */
  refDirection?: RefLocation;
};

/**
 * TimeStamps which specify a specific instant in time. We define three subtypes (FITSTime, JD, MJD), which allow users to explicitly identify the representation and interpretation of the TimeInstant.
 */
export type TimeInstant = Record<string, any>;

/**
 * Time is given as an offset from a specific point in time (time0).
 */
export type TimeOffset = {
  /**
   * A real value with a unit.
   */
  time?: RealQuantity;
  /**
   * TimeStamps which specify a specific instant in time. We define three subtypes (FITSTime, JD, MJD), which allow users to explicitly identify the representation and interpretation of the TimeInstant.
   */
  time0?: TimeInstant;
};

/**
 * This is the abstract basis for a set of simple time domain coordinates which are expected to accommodate the vast majority of use cases. All TimeStamps, by definition, exist in a standard 1-D coordinate space, with domainMin|Max of +/-Infinity. All TimeStamps MUST refer to an appropriate TimeSys.
 */
export type TimeStamp = Record<string, any>;

/**
 * Specialized coordinate system for the Temporal domain. This object SHOULD include an appropriate TimeFrame. If a CoordSpace is not provided, it is assumed to be represented by a Standard 1-Dimensional Coordinate Space as described in Appendix B.
 */
export type TimeSys = {
  xmlId?: string;
};

/**
 * Any specific timing requirements for the observing
 */
export type TimingConstraint = {
  note?: string;
  isAvoidConstraint?: boolean;
};

/**
 * particular time range
 */
export type TimingWindow = {
  "@type"?: string; //proposal:TimingWindow

  _id?: number;

  note?: string;
  isAvoidConstraint?: boolean;
  /**
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  startTime?: Date;
  /**
   * @format date
   * @example "2022-03-10T00:00:00.000Z"
   */
  endTime?: Date;
};

/**
 * Must conform to definition of unit in VOUnit spec.
 */
export type Unit = {
  value?: string;
};

/**
 * @format binary
 */
export type UploadItemSchema = Blob;

export type UserConsentRepresentation = {
  clientId?: string;
  grantedClientScopes?: string[];
  /**
   * @format int64
   */
  createdDate?: number;
  /**
   * @format int64
   */
  lastUpdatedDate?: number;
  /**
   * @deprecated true
   */
  grantedRealmRoles?: string[];
};

export type UserProfileAttributeGroupMetadata = {
  name?: string;
  displayHeader?: string;
  displayDescription?: string;
  annotations?: {
    [key: string]: any;
  };
};

export type UserProfileAttributeMetadata = {
  name?: string;
  displayName?: string;
  required?: boolean;
  readOnly?: boolean;
  annotations?: {
    [key: string]: any;
  };
  validators?: {
    [key: string]: {
      [key: string]: any;
    };
  };
  group?: string;
};

export type UserProfileMetadata = {
  attributes?: UserProfileAttributeMetadata[];
  groups?: UserProfileAttributeGroupMetadata[];
};

export type UserRepresentation = {
  self?: string;
  id?: string;
  origin?: string;
  /**
   * @format int64
   */
  createdTimestamp?: number;
  username?: string;
  enabled?: boolean;
  totp?: boolean;
  emailVerified?: boolean;
  firstName?: string;
  lastName?: string;
  email?: string;
  federationLink?: string;
  serviceAccountClientId?: string;
  attributes?: {
    [key: string]: string[];
  };
  credentials?: CredentialRepresentation[];
  /**
   * @uniqueItems true
   */
  disableableCredentialTypes?: string[];
  requiredActions?: string[];
  federatedIdentities?: FederatedIdentityRepresentation[];
  realmRoles?: string[];
  clientRoles?: {
    [key: string]: string[];
  };
  clientConsents?: UserConsentRepresentation[];
  /**
   * @format int32
   */
  notBefore?: number;
  /**
   * @deprecated true
   */
  applicationRoles?: {
    [key: string]: string[];
  };
  /**
   * @deprecated true
   */
  socialLinks?: SocialLinkRepresentation[];
  groups?: string[];
  access?: {
    [key: string]: boolean;
  };
  userProfileMetadata?: UserProfileMetadata;
};

/**
 * a WikiData identifier
 */
export type WikiDataId = {
  value?: string;
};
